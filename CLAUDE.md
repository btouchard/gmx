# CLAUDE.md — Regles du projet GMX

> Ce fichier est la source de verite pour Claude Code. Lis-le entierement avant chaque action.

---

## REGLES ABSOLUES (NON NEGOCIABLES)

- **JAMAIS de `git push`**. Aucune exception. Commit local uniquement.
- **JAMAIS de mention d'IA, de Claude, de LLM, de "generated by" dans les commits, commentaires ou code.**
- Messages de commit : Conventional Commits (`feat:`, `fix:`, `refactor:`, `test:`, `chore:`, `docs:`), en anglais, concis.
- Avant de commit : `go test ./...` doit passer. Ne commit que du code qui compile et dont les tests passent.

---

## LE PROJET

GMX est un **compilateur/transpileur** qui transforme des fichiers `.gmx` (composants single-file style Vue) en applications **Go** standalone avec **HTMX**.

```
.gmx source → Lexer → Parser → AST → Resolver → Generator → Go code → go build → binary
```

Le compilateur est un **outil CLI** en Go pur. Il n'y a **pas de frontend**, **pas de Docker**, **pas de base de donnees** dans le projet lui-meme. Le code genere par GMX utilise GORM/SQLite, mais le compilateur non.

---

## ARCHITECTURE

### Structure du projet

```
github.com/btouchard/gmx
├── cmd/gmx/                          # CLI (point d'entree)
│   ├── main.go                       # Dispatcher de sous-commandes
│   ├── compile.go                    # Pipeline : lexer → parser → resolver → generator
│   ├── build.go                      # gmx build : compile .gmx → binaire Go
│   ├── run.go                        # gmx run : build + execute
│   └── fmt.go                        # gmx fmt : formate les fichiers .gmx
├── internal/compiler/                # Coeur du compilateur
│   ├── token/                        # Types de tokens
│   ├── lexer/                        # Tokenisation du source .gmx
│   ├── ast/                          # Noeuds de l'AST (models, services, functions, imports...)
│   ├── parser/                       # Parsing des sections <script>, <template>, <style>
│   │   └── shared/                   # Parsing partage : models, services, annotations
│   ├── script/                       # Parser + Transpileur GMX Script → Go
│   ├── resolver/                     # Resolution d'imports multi-fichiers
│   ├── generator/                    # Generation de code Go
│   │   ├── generator.go              # Orchestrateur
│   │   ├── gen_models.go             # Structs + GORM tags + validation + ORM
│   │   ├── gen_handlers.go           # Handlers HTTP + routing
│   │   ├── gen_template.go           # Templates HTML/HTMX
│   │   ├── gen_services.go           # Services (DB, SMTP, HTTP)
│   │   ├── gen_imports.go            # Imports Go
│   │   ├── gen_main.go              # Fonction main()
│   │   ├── gen_helpers.go            # Fonctions utilitaires
│   │   ├── gen_vars.go              # Variables globales (let/const)
│   │   └── analysis.go              # Analyse du code
│   ├── errors/                       # Gestion d'erreurs
│   ├── utils/                        # Utilitaires (camelCase, etc.)
│   └── integration_test.go           # Tests end-to-end du pipeline complet
├── examples/
│   └── demo.gmx                      # Demo complete de toutes les features
├── docs/                             # Documentation MkDocs
├── mkdocs.yml
├── .github/workflows/docs.yml        # Deploy docs sur GitHub Pages
├── README.md
└── LICENSE                           # Apache 2.0
```

### Pipeline de compilation

Chaque phase est independante et testable :

1. **Lexer** (`lexer/`) : source texte → tokens. Gere les sections `<script>`, `<template>`, `<style>`.
2. **Parser** (`parser/`) : tokens → AST. Parse models, services, functions, imports, variables.
3. **Script Parser** (`script/parser.go`) : GMX Script (syntaxe TypeScript-like) → AST de statements.
4. **Script Transpiler** (`script/transpiler.go`) : AST de statements → code Go (`let` → `:=`, `try` → `if err != nil`, etc.).
5. **Resolver** (`resolver/`) : resolution recursive des imports `.gmx`, detection des imports circulaires.
6. **Generator** (`generator/`) : AST → code Go complet (models, handlers, templates, main).

### Regles de dependances

```
cmd/gmx → internal/compiler/{lexer,parser,resolver,generator}
parser → ast, token, errors, script
generator → ast, script (pour le transpileur)
resolver → lexer, parser, ast
```

Chaque package sous `internal/compiler/` ne depend que de ses voisins dans le pipeline. Pas de dependances circulaires.

---

## GO — CONVENTIONS DU PROJET

### Style

- **Go idiomatique**. Standard library autant que possible.
- Module : `github.com/btouchard/gmx`, Go 1.24+.
- Tests : `testing` standard uniquement (pas de testify).
- Pas de linter externe configure — on se fie au compilateur Go et `go vet`.
- Fichiers : `snake_case.go`. Packages : un mot lowercase (`lexer`, `parser`, `token`).

### Error handling

- Wrapper les erreurs avec contexte : `fmt.Errorf("parsing model: %w", err)`.
- Ne jamais ignorer une erreur silencieusement.
- Les phases du compilateur retournent des listes d'erreurs (strings) plutot que des `error` pour accumuler plusieurs diagnostics.

### Tests

- **Table-driven tests** pour les cas multiples.
- Tests colocalises (`*_test.go` a cote du code).
- Pattern de nommage : `TestLexer_StringInterpolation`, `TestGenerator_ModelWithRelation`.
- Integration tests dans `internal/compiler/integration_test.go` : testent le pipeline complet `.gmx` → Go code.
- Couverture actuelle : ~91%.

### Commandes

```bash
# Tous les tests
go test ./...

# Build le compilateur
go build -o gmx ./cmd/gmx

# Utilisation
./gmx build examples/demo.gmx          # → binaire ./demo
./gmx run examples/demo.gmx            # → build + execute
./gmx fmt examples/demo.gmx            # → formate en place
./gmx examples/demo.gmx                # → raccourci pour build
```

---

## CHECKLIST AVANT COMMIT

1. `go test ./...` passe
2. `go build ./cmd/gmx/` compile
3. Message de commit en Conventional Commits, en anglais
4. Pas de `git push`

---

## WORKFLOW DE DEVELOPPEMENT

1. **Comprendre** : lire la demande, identifier quelle phase du compilateur est concernee.
2. **Lire le code existant** : comprendre les patterns en place dans le package concerne.
3. **Implementer** : suivre les conventions existantes du package.
4. **Tester** : ajouter/mettre a jour les tests. Table-driven quand applicable.
5. **Verifier** : `go test ./...` passe, le code compile.
6. **Commit** : message clair, pas de mention d'IA.

---

## CE QUE CLAUDE CODE NE DOIT JAMAIS FAIRE

- Push du code
- Mentionner l'IA/Claude/LLM dans le code, commits ou docs
- Creer des packages fourre-tout (`utils` existe deja et est minimal, ne pas en ajouter)
- Ecrire des tests triviaux sans valeur
- Ignorer les erreurs
- Committer du code qui ne compile pas ou dont les tests echouent
- Casser la retrocompatibilite du CLI sans raison
